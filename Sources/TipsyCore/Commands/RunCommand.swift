import SwiftCLI
import xcodeproj
import PathKit
import SwiftShell
import Foundation

class RunCommand: Command {
    let name = "run"
    let shortDescription = "Start a Tipsy run."
    
    let xcodeWorkspaceName = Parameter()
    let xcodeProjectName = Parameter()
    let xcodeTargetName = Parameter()
    let scenarioProviders = Parameter()
    
    let time = Key<Int>("-t", "--time", description: "Time to keep running Tipsy for.")
    let comprehensive = Flag("-c", "--comprehensive", description: "Do a comprehensive run.")
    let replay = Key<String>("-r", "--replay", description: "Replays a previous run of Tipsy. Pass path to a replay file generated by a previous run.")
    
    let replayFileOutputPath = Key<String>("-o", "--replayfile-output-path", description: "Path to save replay file generated by the run.")
    
    let reset = Flag("-x", "--reset", description: "Reset simulator before starting the run.")
    let uninstall = Key<String>("-u", "--uninstall", description: "App bundle identifier to uninstall before starting the run.")
    

    var optionGroups: [OptionGroup] {
        let runMode: OptionGroup = .atMostOne(time, comprehensive, replay)
        let resetOptions: OptionGroup = .atMostOne(reset, uninstall)
        
        return [runMode, resetOptions]
    }
    
    let autogeneratedXcodeGroupName = "Tipsy Autogenerated"
    let entryPointClassName = "Tipsy_EntryPoint"
    let defaultDeviceIdentifier = "5C60F7BF-42E8-4E0B-AB46-FFD0CE002BBC"
    
    func execute() throws {
        if let bundleIdentifier = uninstall.value {
            uninstallAppWith(bundleIdentifier: bundleIdentifier)
        }
        
        if reset.value {
            resetSimulator()
        }
        
        guard let entryPointPath =  createEntryPoint() else {
            print("Failed to generated entry point.")
            return
        }

        let tempWorkspaceName = tempNameFrom(fileName: xcodeWorkspaceName.value)
        let tempProjectName = tempNameFrom(fileName: xcodeProjectName.value)
        
        startTipsyRun(workspaceName: tempWorkspaceName,
                      targetName: xcodeTargetName.value,
                      entryPointName: entryPointClassName)
        
        cleanUpTempFiles(workspacePath: Path(tempWorkspaceName),
                         projectPath: Path(tempProjectName),
                         entryPointPath: Path(entryPointPath))
    }
}

// MARK: Helpers

extension RunCommand {
    
    func formattedDate() -> String {
        let date = Date()
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy hh:mm a"
        return formatter.string(from: date)
    }
}

// MARK: Simulator

extension RunCommand {
    
    func resetSimulator() {
        print("Shutting down simulator.")
        var output = main.run(bash: "killall Simulator")
        
        if let _ = output.error {
            print("Failed to shutdown simulator.")
            return
        }
        
        print("Resetting simulator.")
        output = main.run(bash: "xcrun simctl erase all")
        
        if let _ = output.error {
            print("Failed to reset simulator.")
            return
        }
        
        print("Reset simulator.")
    }
    
    func uninstallAppWith(bundleIdentifier: String) {
        print("Uninstalling app with bundle identifier \(bundleIdentifier)")
        
        let output = main.run(bash: "xcrun simctl uninstall booted \(bundleIdentifier)")
        
        if let _ = output.error {
            print("Failed to uninstall app.")
        }
        
        print("Uninstalled app.")
        
    }
}

// MARK: Xcode Build

extension RunCommand {
    
    func startTipsyRun(workspaceName: String, targetName: String, entryPointName: String) {
        print("Checking if simulator is running.")
        let output = main.run(bash: "killall -d Simulator")
        
        if output.exitcode == 1 {
            print("Starting simulator app.")
            main.run(bash: "open -a Simulator.app")
            
            print("Waiting for simulator to boot.")
            sleep(25)
        }
        
        print("Started run.")
        
        var testCommand = ""
        if isXcprettyAvailable() {
            testCommand = "set -o pipefail && xcodebuild -workspace \(workspaceName) -scheme \(targetName) -sdk iphonesimulator -destination 'id=\(defaultDeviceIdentifier)' -only-testing:\(targetName)/\(entryPointName) test | xcpretty"
        } else {
            testCommand = "xcodebuild -workspace \(workspaceName) -scheme \(targetName) -sdk iphonesimulator -destination 'id=\(defaultDeviceIdentifier)' -only-testing:\(targetName)/\(entryPointName) test"
        }
        
        do {
            try main.runAndPrint(bash: testCommand)
        } catch {
            print("Something went wrong while trying to run test command.")
        }
        
        print("Finished run.")
    }
    
    func isXcprettyAvailable() -> Bool {
        let output = main.run(bash: "which xcpretty")
        
        if output.exitcode == 0 {
            return true
        }
        
        return false
    }
}

// MARK: Xcode Workspace/Project

extension RunCommand {
    
    /**
     Create entry point for Tipsy and returns the autogenerated class path.
     */
    func createEntryPoint() -> String? {
        print("Creating entry point")
        
        // Create temp project
        var xcodeProjectPath = Path()
        let xcodeProject: XcodeProj
        
        do {
            xcodeProjectPath = try createTempCopyOf(path: Path(xcodeProjectName.value))
            xcodeProject = try XcodeProj(path: xcodeProjectPath)
        } catch {
            print("Failed to create temp project.")
            return nil
        }
        
        // Create temp workspace
        let workspacePath = Path(xcodeWorkspaceName.value)
        
        do {
            try createTempCopyFromWorkspaceAt(path: workspacePath, tempProjectPath: xcodeProjectPath)
        } catch {
            print("Failed to create temp workspace.")
            return nil
        }
        
        // Create a new group under the root group.
        let autogeneratedGroup: PBXGroup
        
        do {
            let rootGroup = try xcodeProject.pbxproj.rootGroup()
            autogeneratedGroup = PBXGroup(sourceTree: .group, name: autogeneratedXcodeGroupName)
            rootGroup?.children.append(autogeneratedGroup)
            xcodeProject.pbxproj.add(object: autogeneratedGroup)
        } catch {
            print("Failed to create a new group under temp project.")
            return nil
        }
        
        // Generate file and add it to the project.
        let autogeneratedFile: PBXFileReference
        let autogeneratedFilePath: String
        
        do {
            autogeneratedFilePath = generateTestClass()
            autogeneratedFile = try autogeneratedGroup.addFile(at: Path(autogeneratedFilePath), sourceRoot: Path.current)
            let buildFile = PBXBuildFile(file: autogeneratedFile)
            xcodeProject.pbxproj.add(object: buildFile)
        } catch {
            print("Failed to generate entry point and add it to project.")
            return nil
        }
        
        // Get the sources build phase of the passed target and add the autogenerated file to it.
        do {
            let sourcesBuildPhase = try xcodeProject.pbxproj.targets(named: xcodeTargetName.value).first?.sourcesBuildPhase()
            _ = try sourcesBuildPhase?.add(file: autogeneratedFile)
        } catch {
            print("Failed to add entry point to build phases.")
            return nil
        }
        
        // Write everything back to disk.
        do {
            try xcodeProject.write(path: xcodeProjectPath, override: true)
        } catch {
            print("Failed to save temp project to disk.")
            return nil
        }
        
        print("Created entry point at \(autogeneratedFilePath).")
        
        return autogeneratedFilePath
    }
    
    /**
     Creates a temp copy of the workspace, and modifies it to include the temp project.
     */
    func createTempCopyFromWorkspaceAt(path: Path, tempProjectPath: Path) throws {
        let tempXcodeWorkspacePath = try createTempCopyOf(path: path)
        let xcodeWorkspace = try XCWorkspace(path: tempXcodeWorkspacePath)
        
        try xcodeWorkspace.data.children .forEach { (dataElement) in
            switch dataElement {
            case .file(let file):
                if file.location.path.contains(xcodeProjectName.value) {
                    file.location = try XCWorkspaceDataElementLocationType(string: "group:\(tempProjectPath.string)")
                }
            default:
                break
            }
        }
        
        try xcodeWorkspace.write(path: tempXcodeWorkspacePath)
    }
    
    func generateTestClass() -> String {
        let classDefinition = """
        //
        //  This class has been automatically generated by Tipsy.
        //  Modifications are going to be overridden with every
        //  run of Tipsy using the CLI.
        //
        //  Last generated on \(formattedDate()).
        //
        
        import Tipsy
        
        class \(entryPointClassName): TipsyTestCase {
        
            func test_startTipsyRun() {
                let scenarios = Bartender.serve(fromProviders: [
                    \(createScenarioProvidersArrayFrom(classesNames: scenarioProviders.value))
                ])
        
                Tipsy.runner.add(scenarios: scenarios)
                \(replayFilePathStatement())
                \(runStatementForCurrentRunMode())
        
                Tipsy.runner.wait(self)
            }
        }
        """
        
        let path = Path.current + Path("\(entryPointClassName).swift")
        
        do {
            try path.write(classDefinition)
        } catch {
            print("Failed to create \(entryPointClassName).swift")
        }
        
        return path.string
    }
    
    func createScenarioProvidersArrayFrom(classesNames: String) -> String {
        let classNamesArray = classesNames.split(separator: ",")
        let trimmedClassesNamesArray = classNamesArray.map { "\($0.trimmingCharacters(in: .whitespaces)).self" }
        return trimmedClassesNamesArray.joined(separator: ", ")
    }
    
    func runStatementForCurrentRunMode() -> String {
        if comprehensive.value {
            return "Tipsy.runner.runComprehensively()"
        } else if let replayFileInputPath = replay.value {
            return """
            // Replay run
                    let url = URL(string: "file://\(replayFileInputPath)")!
                    let data = try! Data.init(contentsOf: url)
                    let decoder = JSONDecoder()
            
                    do {
                        let steps = try decoder.decode([Step].self, from: data)
                        Tipsy.runner.run(steps: steps)
                    } catch {
                        fatalError("Failed to read replay file at \\(url)")
                    }
            """
        } else {
            return "Tipsy.runner.runFor(duration: \(time.value ?? 60))"
        }
    }
    
    func replayFilePathStatement() -> String {
        if let path = replayFileOutputPath.value {
            return "Tipsy.runner.replayFileOutputPath = \"\(path)\""
        }
        
        return ""
    }
}

// MARK: File Manipulation

extension RunCommand {
    
    func createTempCopyOf(path: Path) throws -> Path {
        let tempPath = tempPathFrom(path: path)
        try cleanUpTempFilesAt(path: tempPath)
        try path.copy(tempPath)
        return tempPath
    }
    
    func cleanUpTempFilesAt(path: Path) throws {
        if path.exists {
            try path.delete()
        }
    }
    
    func tempPathFrom(path: Path) -> Path {
        return Path(tempNameFrom(fileName: path.string))
    }
    
    func tempNameFrom(fileName: String) -> String {
        let nameComponents = fileName.components(separatedBy: ".")
        let tempName = "\(nameComponents[0])-temp.\(nameComponents[1])"
        
        return tempName
    }
    
    func cleanUpTempFiles(workspacePath: Path, projectPath: Path, entryPointPath: Path) {
        print("Cleaning up temp files.")
        
        do {
            try cleanUpTempFilesAt(path: workspacePath)
            try cleanUpTempFilesAt(path: projectPath)
            try cleanUpTempFilesAt(path: entryPointPath)
        } catch {
            print("Failed to clean up temp files after run.")
        }
    }
}
