/*
 tipsy run runmode options
 runmode:
 1. time
  Options
      Time in minutes
      Example: tipsy run time 10
 2. comprehensive

 Specifying names of scenario classes to run:
 * By default, all classes with the "Scenarios.swift" prefix should be included.
 * Add the option of specifying class names. (keyed options)
 
 tipsy run comprehensive --class APIScenarios.swift
 tipsy run time 15 --class APIScenarios.swift
--
 Todo:
 1. Work on the command that runs all for time
    a. Explore if a Tipsyfile is needed to specify things like the target to test
    b. Start by running the Xcode command to run tests for Test.swift
        xcodebuild -workspace Tipsy.xcworkspace -scheme Tipsy-Example -sdk iphonesimulator -destination 'platform=iOS Simulator,OS=12.1,name=iPhone 8' -only-testing:Tipsy_Tests/Test test
        Note: after the file is generated, it also needs to be added to the test target that has the Scenarios
        See:
            https://github.com/tuist/xcodeproj
            https://github.com/tuist/xcodeproj/issues/341
            Add a new group to add the file to:
            https://github.com/tuist/xcodeproj/issues/43
            Add file to group:
            https://github.com/tuist/xcodeproj/issues/57
 
            https://github.com/CocoaPods/Xcodeproj
 
    c. Work on generating a temp test.swift file
    d. Figure out how to reset the simulator before starting the run
 
--
 How Tipsy should be used:
 
 App
    - Adds Tipsy via CocoaPods
    - Adds a test target that contains all scanarios
    - Uses CLI to run that target, so scheme and workspace need to be specified.
 
*/
import SwiftCLI
import xcodeproj
import PathKit
import SwiftShell
import Foundation

class RunCommand: Command {
    let name = "run"
    let shortDescription = "Start a Tipsy run."
    
    let xcodeWorkspaceName = Parameter()
    let xcodeProjectName = Parameter()
    let xcodeTargetName = Parameter()
    let scenarioProviders = Parameter()
    let runType = OptionalParameter()
    
    let time = Key<Int>("-t", "--time", description: "Time to keep running Tipsy for.")
    let comprehensive = Flag("-c", "--comprehensive", description: "Do a comprehensive run.")

    let reset = Flag("-r", "--reset", description: "Reset simulator before starting the run.")
    let uninstall = Key<String>("-u", "--uninstall", description: "App bundle identifier to uninstall before starting the run.")

    var optionGroups: [OptionGroup] {
        let runMode: OptionGroup = .atMostOne(time, comprehensive)
        let resetOptions: OptionGroup = .atMostOne(reset, uninstall)
        
        return [runMode, resetOptions]
    }
    
    let autogeneratedXcodeGroupName = "Tipsy Autogenerated"
    let entryPointClassName = "Tipsy_EntryPoint"
    let defaultDeviceIdentifier = "B3C24A3C-00B8-4BD7-83CB-44B60FCE9DBB"
    
    func execute() throws {
        if let bundleIdentifier = uninstall.value {
            uninstallAppWith(bundleIdentifier: bundleIdentifier)
        }
        
        if reset.value {
            resetSimulator()
        }
        
        guard let entryPointPath =  createEntryPoint() else {
            print("Failed to generated entry point.")
            return
        }

        let tempWorkspaceName = tempNameFrom(fileName: xcodeWorkspaceName.value)
        let tempProjectName = tempNameFrom(fileName: xcodeProjectName.value)
        
        startTipsyRun(workspaceName: tempWorkspaceName,
                      targetName: xcodeTargetName.value,
                      entryPointName: entryPointClassName)
        
        cleanUpTempFiles(workspacePath: Path(tempWorkspaceName),
                         projectPath: Path(tempProjectName),
                         entryPointPath: Path(entryPointPath))
    }
}

// MARK: Helpers

extension RunCommand {
    
    func formattedDate() -> String {
        let date = Date()
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy hh:mm a"
        return formatter.string(from: date)
    }
}

// MARK: Simulator

extension RunCommand {
    
    func resetSimulator() {
        print("Shutting down simulator.")
        var output = main.run(bash: "killall Simulator")
        
        if let _ = output.error {
            print("Failed to shutdown simulator.")
            return
        }
        
        print("Resetting simulator.")
        output = main.run(bash: "xcrun simctl erase all")
        
        if let _ = output.error {
            print("Failed to reset simulator.")
            return
        }
        
        print("Reset simulator.")
    }
    
    func uninstallAppWith(bundleIdentifier: String) {
        print("Uninstalling app with bundle identifier \(bundleIdentifier)")
        
        let output = main.run(bash: "xcrun simctl uninstall booted \(bundleIdentifier)")
        
        if let _ = output.error {
            print("Failed to uninstall app.")
        }
        
        print("Uninstalled app.")
        
    }
}

// MARK: Xcode Build

extension RunCommand {
    
    func startTipsyRun(workspaceName: String, targetName: String, entryPointName: String) {
        print("Checking if simulator is running.")
        let output = main.run(bash: "killall -d Simulator")
        
        if output.exitcode == 1 {
            print("Starting simulator app.")
            main.run(bash: "open -a Simulator.app")
            
            print("Waiting for simulator to boot.")
            sleep(25)
        }
        
        print("Started run.")
        
        var testCommand = ""
        if isXcprettyAvailable() {
            testCommand = "set -o pipefail && xcodebuild -workspace \(workspaceName) -scheme \(targetName) -sdk iphonesimulator -destination 'id=\(defaultDeviceIdentifier)' -only-testing:\(targetName)/\(entryPointName) test | xcpretty"
        } else {
            testCommand = "xcodebuild -workspace \(workspaceName) -scheme \(targetName) -sdk iphonesimulator -destination 'id=\(defaultDeviceIdentifier)' -only-testing:\(targetName)/\(entryPointName) test"
        }
        
        do {
            try main.runAndPrint(bash: testCommand)
        } catch {
            print("Something went wrong while trying to run test command.")
        }
        
        print("Finished run.")
    }
    
    func isXcprettyAvailable() -> Bool {
        let output = main.run(bash: "which xcpretty")
        
        if output.exitcode == 0 {
            return true
        }
        
        return false
    }
}

// MARK: Xcode Workspace/Project

extension RunCommand {
    
    /**
     Create entry point for Tipsy and returns the autogenerated class path.
     */
    func createEntryPoint() -> String? {
        print("Creating entry point")
        
        // Create temp project
        var xcodeProjectPath = Path()
        let xcodeProject: XcodeProj
        
        do {
            xcodeProjectPath = try createTempCopyOf(path: Path(xcodeProjectName.value))
            xcodeProject = try XcodeProj(path: xcodeProjectPath)
        } catch {
            print("Failed to create temp project.")
            return nil
        }
        
        // Create temp workspace
        let workspacePath = Path(xcodeWorkspaceName.value)
        
        do {
            try createTempCopyFromWorkspaceAt(path: workspacePath, tempProjectPath: xcodeProjectPath)
        } catch {
            print("Failed to create temp workspace.")
            return nil
        }
        
        // Create a new group under the root group.
        let autogeneratedGroup: PBXGroup
        
        do {
            let rootGroup = try xcodeProject.pbxproj.rootGroup()
            autogeneratedGroup = PBXGroup(sourceTree: .group, name: autogeneratedXcodeGroupName)
            rootGroup?.children.append(autogeneratedGroup)
            xcodeProject.pbxproj.add(object: autogeneratedGroup)
        } catch {
            print("Failed to create a new group under temp project.")
            return nil
        }
        
        // Generate file and add it to the project.
        let autogeneratedFile: PBXFileReference
        let autogeneratedFilePath: String
        
        do {
            autogeneratedFilePath = generateTestClass()
            autogeneratedFile = try autogeneratedGroup.addFile(at: Path(autogeneratedFilePath), sourceRoot: Path.current)
            let buildFile = PBXBuildFile(file: autogeneratedFile)
            xcodeProject.pbxproj.add(object: buildFile)
        } catch {
            print("Failed to generate entry point and add it to project.")
            return nil
        }
        
        // Get the sources build phase of the passed target and add the autogenerated file to it.
        do {
            let sourcesBuildPhase = try xcodeProject.pbxproj.targets(named: xcodeTargetName.value).first?.sourcesBuildPhase()
            _ = try sourcesBuildPhase?.add(file: autogeneratedFile)
        } catch {
            print("Failed to add entry point to build phases.")
            return nil
        }
        
        // Write everything back to disk.
        do {
            try xcodeProject.write(path: xcodeProjectPath, override: true)
        } catch {
            print("Failed to save temp project to disk.")
            return nil
        }
        
        print("Created entry point at \(autogeneratedFilePath).")
        
        return autogeneratedFilePath
    }
    
    /**
     Creates a temp copy of the workspace, and modifies it to include the temp project.
     */
    func createTempCopyFromWorkspaceAt(path: Path, tempProjectPath: Path) throws {
        let tempXcodeWorkspacePath = try createTempCopyOf(path: path)
        let xcodeWorkspace = try XCWorkspace(path: tempXcodeWorkspacePath)
        
        try xcodeWorkspace.data.children .forEach { (dataElement) in
            switch dataElement {
            case .file(let file):
                if file.location.path.contains(xcodeProjectName.value) {
                    file.location = try XCWorkspaceDataElementLocationType(string: "group:\(tempProjectPath.string)")
                }
            default:
                break
            }
        }
        
        try xcodeWorkspace.write(path: tempXcodeWorkspacePath)
    }
    
    func generateTestClass() -> String {
        let classDefinition = """
        //
        //  This class has been automatically generated by Tipsy.
        //  Modifications are going to be overridden with every
        //  run of Tipsy using the CLI.
        //
        //  Last generated on \(formattedDate()).
        //
        
        import Tipsy
        
        class \(entryPointClassName): TipsyTestCase {
        
            func test_startTipsyRun() {
                let scenarios = Bartender.serve(fromProviders: [
                    \(createScenarioProvidersArrayFrom(classesNames: scenarioProviders.value))
                ])
        
                Tipsy.runner.add(scenarios: scenarios)
                \(runStatementForCurrentRunMode())
        
                Tipsy.runner.wait(self)
            }
        }
        """
        
        let path = Path.current + Path("\(entryPointClassName).swift")
        
        do {
            try path.write(classDefinition)
        } catch {
            print("Failed to create \(entryPointClassName).swift")
        }
        
        return path.string
    }
    
    func createScenarioProvidersArrayFrom(classesNames: String) -> String {
        let classNamesArray = classesNames.split(separator: ",")
        let trimmedClassesNamesArray = classNamesArray.map { "\($0.trimmingCharacters(in: .whitespaces)).self" }
        return trimmedClassesNamesArray.joined(separator: ", ")
    }
    
    func runStatementForCurrentRunMode() -> String {
        if comprehensive.value {
            return "Tipsy.runner.runComprehensively()"
        } else {
            return "Tipsy.runner.runFor(duration: \(time.value ?? 60))"
        }
    }
}

// MARK: File Manipulation

extension RunCommand {
    
    func createTempCopyOf(path: Path) throws -> Path {
        let tempPath = tempPathFrom(path: path)
        try cleanUpTempFilesAt(path: tempPath)
        try path.copy(tempPath)
        return tempPath
    }
    
    func cleanUpTempFilesAt(path: Path) throws {
        if path.exists {
            try path.delete()
        }
    }
    
    func tempPathFrom(path: Path) -> Path {
        return Path(tempNameFrom(fileName: path.string))
    }
    
    func tempNameFrom(fileName: String) -> String {
        let nameComponents = fileName.components(separatedBy: ".")
        let tempName = "\(nameComponents[0])-temp.\(nameComponents[1])"
        
        return tempName
    }
    
    func cleanUpTempFiles(workspacePath: Path, projectPath: Path, entryPointPath: Path) {
        print("Cleaning up temp files.")
        
        do {
            try cleanUpTempFilesAt(path: workspacePath)
            try cleanUpTempFilesAt(path: projectPath)
            try cleanUpTempFilesAt(path: entryPointPath)
        } catch {
            print("Failed to clean up temp files after run.")
        }
    }
}
